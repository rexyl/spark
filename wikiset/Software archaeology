Software archaeology or software archeology is the study of poorly documented or undocumented legacy software implementations, as part of software maintenance. Software archaeology, named by analogy with archaeology, includes the reverse engineering of software modules, and the application of a variety of tools and processes for extracting and understanding program structure and recovering design information. Software archaeology may reveal dysfunctional team processes which have produced poorly designed or even unused software modules. The term has been in use for decades, and reflects a fairly natural metaphor: a programmer reading legacy code may feel that he or she is in the same situation as an archaeologist exploring the rubble of an ancient civilization.


== TechniquesEdit ==
A workshop on Software Archaeology at the 2001 OOPSLA (Object-Oriented Programming, Systems, Languages & Applications) conference identified the following software archaeology techniques, some of which are specific to object-oriented programming:
Scripting languages to build static reports and for filtering diagnostic output
Ongoing documentation in HTML pages or Wikis
Synoptic signature analysis, statistical analysis, and software visualization tools
Reverse-engineering tools
Operating-system-level tracing via truss or strace
Search engines and tools to search for keywords in source files
IDE file browsing
Unit testing frameworks such as JUnit and CppUnit
API documentation generation using tools such as Javadoc and doxygen
Debuggers
More generally, Andy Hunt and Dave Thomas note the importance of version control, dependency management, text indexing tools such as GLIMPSE and SWISH-E, and "[drawing] a map as you begin exploring."
Like true archaeology, software archaeology involves investigative work to understand the thought processes of one's predecessors. At the OOPSLA workshop, Ward Cunningham suggested a synoptic signature analysis technique which gave an overall "feel" for a program by showing only punctuation, such as semicolons and curly braces. In the same vein, Cunningham has suggested viewing programs in 2 point font in order to understand the overall structure. Another technique identified at the workshop was the use of aspect-oriented programming tools such as AspectJ to systematically introduce tracing code without directly editing the legacy program.
Network and temporal analysis techniques can reveal the patterns of collaborative activity by the developers of legacy software, which in turn may shed light on the strengths and weaknesses of the software artifacts produced.
Michael Rozlog of Embarcadero Technologies has described software archaeology as a six-step process which enables programmers to answer questions such as "What have I just inherited?" and "Where are the scary sections of the code?" These steps, similar to those identified by the OOPSLA workshop, include using visualization to obtain a visual representation of the program's design, using software metrics to look for design and style violations, using unit testing and profiling to look for bugs and performance bottlenecks, and assembling design information recovered by the process. Software archaeology can also be a service provided to programmers by external consultants.
 Mitch Rosenberg of InfoVentions.net, Inc. claims that the first law of software archaeology (he calls it code or data archaeology) is:
Everything that is there is there for a reason, and there are 3 possible reasons:
It used to need to be there but no longer does
It never needed to be there and the person that wrote the code had no clue
It STILL needs to be there and YOU have no clue
The corollary to this "law" is that, until you know which was the reason, you should NOT modify the code (or data).
Software archaeology has continued to be a topic of discussion at more recent software engineering conferences.


== See alsoEdit ==

Software architecture recovery
Code refactoring
Software brittleness
Software rot
Software entropy
Abandonware


== ReferencesEdit ==
^ a b Gregorio Robles, Jesus M. Gonzalez-Barahona, and Israel Herraiz, "An Empirical Approach to Software Archaeology," Poster Proceedings of the International Conference on Software Maintenance, 2005.
^ "Agile Legacy System Analysis and Integration Modeling" by Scott W. Ambler at agilemodeling.com, accessed 20 August 2010: "Without accurate documentation, or access to knowledgeable people, your last resort may be to analyze the source code for the legacy system... This effort is often referred to as software archaeology."
^ Bryon Moyer, "Software Archeology: Modernizing Old Systems," Embedded Technology Journal, March 4, 2009.
^ Richard Hopkins and Kevin Jenkins, Eating the IT Elephant: Moving from greenfield development to brownfield, Addison-Wesley, 2008, ISBN 0-13-713012-0, p. 93.
^ Diomidis Spinellis and Georgios Gousios, Beautiful Architecture, O'Reilly, 2009, ISBN 0-596-51798-X, p. 29.
^ An early discussion is Judith E. Grass, "Object-Oriented Design Archaeology with CIA++," Computing Systems, Vol. 5, No. 1, Winter 1992.
^ a b c d e Andy Hunt and Dave Thomas, "Software Archaeology", IEEE Software, vol. 19, no. 2, pp. 20-22, Mar./Apr. 2002, doi:10.1109/52.991327.
^ Ward Cunningham, "Signature Survey: A Method for Browsing Unfamiliar Code," Workshop Position Statement, Software Archeology: Understanding Large Systems, OOPSLA 2001.
^ "Software Archeology" on John D. Cook's blog The Endeavour, November 10, 2009.
^ Cleidson de Souza, Jon Froehlich, and Paul Dourish, "Seeking the Source: Software Source Code as a Social and Technical Artifact," Proceedings of the 2005 International ACM SIGGROUP Conference on Supporting Group Work, pp. 197-206.
^ a b Michael Rozlog, "Software Archeology: What Is It and Why Should Java Developers Care?," article on java.sys-con.com, January 28, 2008.
^ Simon Sharwood, Raiders of the Lost Code, ZDNet, November 3, 2004.
^ For example, the 32nd ACM/IEEE International Conference on Software Engineering in Cape Town, South Africa in May 2010.


== External linksEdit ==
Position papers, OOPSLA 2001 Workshop on Software Archeology: Understanding Large Systems
Writing code, reading code and software archeology, Once More into the Code blog at Computerworld, September 23, 2009
How To Apply Software Archeology To Your Development Process, presentation by Michael Rozlog, March 13, 2008
OOPSLA 2008 Podcast with Grady Booch on software archaeology and related topics